import React, { useState, useRef } from 'react';
import { Image, Dimensions, StyleSheet, View, Animated, PanResponder } from "react-native";

// import { PanGestureHandler, State } from 'react-native-gesture-handler';
// import Animated, { useSharedValue, useAnimatedStyle, withSpring } from 'react-native-reanimated';


// const coinSize = screenWidth * 0.05; // 15% —à–∏—Ä–∏–Ω–∏ –µ–∫—Ä–∞–Ω–∞

export default function Penny({ index, setActiveCoin, moveCoin, round, setCoinData,coinSize, handChangePointsTest}) {

    const position = useRef(new Animated.ValueXY({ x: 0, y: 0 })).current;
    const startCoords = { x: position.x.__getValue(), y: position.y.__getValue() };
    // const [data, setData] = useState({ coins: [] }); // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑ coins

	// const screenWidth = Dimensions.get("window").width;
	// const coinSize = screenWidth * 0.05; // –†–æ–∑–º—ñ—Ä –º–æ–Ω–µ—Ç–∫–∏ (~15% —à–∏—Ä–∏–Ω–∏ –µ–∫—Ä–∞–Ω—É)


    const lastSpeed = useRef(0);
    // const lastDirection = useRef(null);
    // const lastHandChangeTime = useRef(null);
    const angleHistory=useRef([]);
    // const [handChangePoints, setHandChangePoints] = useState([]); 

    const handChangePoints = useRef([]);


    ///////////////////////////////////////////////////////////////////////debug
    // –î–æ–¥–∞—î–º–æ —Ç–æ—á–∫—É –∑–º—ñ–Ω–∏ —Ä—É–∫–∏
    const registerHandChange = (x, y, time) => { //debug
        // setHandChangePoints((prevPoints) => {
        //     const updatedPoints = [...prevPoints, { x, y }];
        //     console.log("Updated points inside setter:", updatedPoints);
        //     return updatedPoints;
        // });
        handChangePoints.current.push({ x, y , time});

        // –Ø–∫—â–æ –≤–∏ —Ö–æ—á–µ—Ç–µ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –∑–º—ñ–Ω–∏, –≤–∏ –º–æ–∂–µ—Ç–µ –¥–æ–¥–∞—Ç–∏ –∫–æ–Ω—Å–æ–ª—å
        // console.log("Updated points:", handChangePoints.current);


    };
    /////////////////////////////////////////////////////////////////////

    
    const startTime = useRef(0); //—â–æ–± –æ–Ω–æ–≤–ª—é–≤–∞–ª–æ—Å—è –æ–¥—Ä–∞–∑—É —ñ –Ω–µ —á–µ–∫–∞–ª–æ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥—É —è–∫ —É —é–∑—Å—Ç–µ–π—Ç
    // const endTimeBackup = useRef(0);


    const droppedCoin = useRef(false);
    const droppedCoinPoints = useRef([]);
    // –î–æ–¥–∞—î–º–æ —Ç–æ—á–∫—É error
    const registerDroppedCoin = (x, y, time) => { 
        const existingIndex = droppedCoinPoints.current.findIndex(
            (coin) => coin.x === x && coin.y === y
        )
        if(existingIndex === -1){
            droppedCoinPoints.current.push({ x, y , time });

        }else{
            droppedCoinPoints.current[existingIndex].time = 
            time - droppedCoinPoints.current[existingIndex].time;

        }
        
        console.log("Error points:", droppedCoinPoints.current);

    };


    

    const collectCoinData = (coinId, startCoords, endCoords) => {
        const endTime = Date.now();

		console.log("end time before fill", endTime);
        // const timeTaken = (endTime - startTime.current) / 1000;
      
        const coinData = {
            id: coinId,
            start_coordinates: {x: startCoords.x, y: startCoords.y},
            end_coordinates: {x: endCoords.x , y: endCoords.y},
            // time: timeTaken,
            time_start: startTime.current,
            time_end: endTime,
            errors: droppedCoinPoints.current,
            // change_hand_moment: changeHandMoment,
            hand_change_points: handChangePoints.current,
            round: round
        };
    
		// handChangePoints.current.length = 0;
        // droppedCoinPoints.current.length = 0;
		// console.log('check if array is empty', droppedCoinPoints.current );
        // setCoinData((prevData) => [...prevData, coinData]); 
        updateOrAddCoin(coinData)

        // console.log("Hand change points:", handChangePoints);
        // console.log("Error points:", droppedCoinPoints.current);


        // endTimeBackup.current = endTime;
    };


    //I DO NOT NEED THIS. WE UPDATING COINS ON THE VERY END
    function updateOrAddCoin(newCoinData) {
        setCoinData((prevCoinData) => {
          // –®—É–∫–∞—î–º–æ –∑–∞–ø–∏—Å, —è–∫–∏–π –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î id –º–æ–Ω–µ—Ç–∫–∏ —ñ —Ä–∞—É–Ω–¥—É
            const existingIndex = prevCoinData.findIndex(
                (coin) => coin.id === newCoinData.id && coin.round === newCoinData.round
            );

        
            // –Ø–∫—â–æ –∑–∞–ø–∏—Å—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ ‚Äî –¥–æ–¥–∞—î–º–æ –Ω–æ–≤–∏–π
            if (existingIndex === -1) {
                console.log("Round is", newCoinData.round);
                // handChangePoints.current.length = 0;
                // droppedCoinPoints.current.length = 0;
                // console.log('check if array is empty', handChangePoints.current );

                return [...prevCoinData, newCoinData];
            }
        
            // –Ø–∫—â–æ –∑–∞–ø–∏—Å –∑–Ω–∞–π–¥–µ–Ω–æ ‚Äî —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π –æ–±'—î–∫—Ç —ñ–∑ –æ–Ω–æ–≤–ª–µ–Ω–∏–º–∏ –¥–∞–Ω–∏–º–∏
            const updatedCoin = {
                ...prevCoinData[existingIndex],
                // –û–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ –ø–æ—Ç—Ä—ñ–±–Ω—ñ –ø–æ–ª—è
                end_coordinates: newCoinData.end_coordinates,
                time_end: newCoinData.time_end,
                // errors: [


                //     ...prevCoinData[existingIndex].errors.slice(0, -1), // –£—Å—ñ –ø–æ–º–∏–ª–∫–∏, –∫—Ä—ñ–º –æ—Å—Ç–∞–Ω–Ω—å–æ—ó
                //     {
                //     ...prevCoinData[existingIndex].errors.at(-1), // –ë–µ—Ä–µ–º–æ –æ—Å—Ç–∞–Ω–Ω—é –ø–æ–º–∏–ª–∫—É
                //     time: prevCoinData[existingIndex].errors.at(-1)?.time - newCoinData.time_start // –í—ñ–¥–Ω—ñ–º–∞—î–º–æ —á–∞—Å —Å—Ç–∞—Ä—Ç—É –Ω–æ–≤–æ–≥–æ –∑–∞–ø–∏—Å—É
                //     },
                //     // ...newCoinData.errors // –î–æ–¥–∞—î–º–æ –Ω–æ–≤—ñ –ø–æ–º–∏–ª–∫–∏
                // ],
                // hand_change_points: [
                // ...prevCoinData[existingIndex].hand_change_points,
                // ...newCoinData.hand_change_points
                // ]
                errors: newCoinData.errors,
                hand_change_points: newCoinData.hand_change_points
            };
            // console.log('previous change hand points', prevCoinData[existingIndex].hand_change_points);
            // console.log(' new hand change points', newCoinData.hand_change_points);
            // console.log('updated coin hand change points', updatedCoin.hand_change_points);



            // handChangePoints.current.length = 0;
            // droppedCoinPoints.current.length = 0;
            // console.log("Updated coin error time", updatedCoin.errors);
            // console.log('check if array is empty', handChangePoints.current );

          
          // –ü–æ–≤–µ—Ä—Ç–∞—î–º–æ –Ω–æ–≤–∏–π –º–∞—Å–∏–≤ –∑ –æ–Ω–æ–≤–ª–µ–Ω–∏–º –∑–∞–ø–∏—Å–æ–º
            return [
                ...prevCoinData.slice(0, existingIndex),
                updatedCoin,
                ...prevCoinData.slice(existingIndex + 1)
            ];
        });
        // handChangePoints.current.length = 0;
        // droppedCoinPoints.current.length = 0;

      }
    


    const panResponder = useRef(
        PanResponder.create({

            onStartShouldSetPanResponder: () => true, //proccessing every touch to the coin
            onPanResponderGrant: () => {
                setActiveCoin(index); // –ó–∞–ø–∏—Å—É—î–º–æ, —è–∫—É –º–æ–Ω–µ—Ç—É –≤–∑—è–ª–∏
                startTime.current = Date.now(); // –û–Ω–æ–≤–ª—é—î—Ç—å—Å—è –±–µ–∑ –≤–∏–∫–ª–∏–∫—É —Ä–µ—Ä–µ–Ω–¥–µ—Ä—É
				// console.log('start time is ', startTime.current);

                if(droppedCoin.current){
                    // console.log("#########–ü–æ–º–∏–ª–∫–∞!");
					//coin is picked
                    registerDroppedCoin(position.x._value, position.y._value, Date.now());
                    // console.log(`error points detail ${position.x._value}`);
                }
                droppedCoin.current = false;


                // console.log(`active index is : ${index}`);
                position.setOffset({ x: position.x._value, y: position.y._value }); //save current pos
                position.setValue({ x: 0, y: 0 }); // –°–∫–∏–¥–∞—î–º–æ dx/dy, —â–æ–± —Ä—É—Ö –±—É–≤ –≤—ñ–¥–Ω–æ—Å–Ω–æ –Ω–æ–≤–æ—ó —Ç–æ—á–∫–∏
 
            },
            onPanResponderMove:(event, gestureState) =>{
                // const speed = Math.sqrt(gestureState.vx ** 2 + gestureState.vy ** 2); // –ó–∞–≥–∞–ª—å–Ω–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å
                // const directionRadians = Math.atan2(gestureState.dy, gestureState.dx); // –ö—É—Ç —Ä—É—Ö—É
                // // const directionDegrees = directionRadians * (180 / Math.PI);
                // // const directionChange = Math.abs(directionDegrees - lastDirection.current);

                // angleHistory.current.push(directionRadians);
                // if (angleHistory.current.length > 13) {
                //     angleHistory.current.shift();
                // }

                // const avgAngleChange = Math.abs(
                //     toDegrees(angleHistory.current[angleHistory.current.length - 1]) - 
                //     toDegrees(angleHistory.current[0])
                // );

                // if (lastSpeed.current < 0.2 && speed > 0.3 && avgAngleChange > 0.1) {
                //     // console.log(`direction change ${directionDegrees} and last ${lastDirection.current}`);
                //     console.log(`angle history ${avgAngleChange}`);
                //     console.log(`üîÑ –ú–æ–∂–ª–∏–≤–∞ –∑–º—ñ–Ω–∞ —Ä—É–∫–∏! Speed ${speed}, coordinates(x) ${ position.x._value}`);
                //     lastHandChangeTime.current = Date.now();

                //     // –†–µ—î—Å—Ç—Ä—É—î–º–æ –º—ñ—Å—Ü–µ –∑–º—ñ–Ω–∏ —Ä—É–∫–∏
                //     registerHandChange(position.x._value, position.y._value);

                // }

                // lastSpeed.current = speed;
                // lastDirection.current = directionDegrees;
                // Animated.event(
                //     [null, { dx: position.x, dy: position.y }],
                //     { useNativeDriver: false }
                // )
                getChangeHand(gestureState);
                Animated.event([null, { dx: position.x, dy: position.y }], { useNativeDriver: false })(event, gestureState);
    
                

            }, 
            onPanResponderRelease: () => {
                setActiveCoin(null);
                position.flattenOffset(); // –ó–∞–ø–∏—Å—É—î–º–æ –Ω–æ–≤—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ —è–∫ –ø–æ—á–∞—Ç–∫–æ–≤—É —Ç–æ—á–∫—É

				const endCoords = { x: position.x.__getValue(), y: position.y.__getValue() };
                collectCoinData(index, startCoords, endCoords);
               

                // –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ—Ä–µ–∫—Ç–Ω—ñ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –ø—ñ—Å–ª—è —Ä—É—Ö—É
                const dropZone = getDropZone(position.x.__getValue(), position.y.__getValue());

                // –ü–µ—Ä–µ–º—ñ—â–∞—î–º–æ –º–æ–Ω–µ—Ç—É
                if (dropZone) {
                    // const endCoords = { x: position.x.__getValue(), y: position.y.__getValue() };
        // console.log("Hand change points:", handChangePoints);

                    
                    // collectCoinData(index, startCoords, endCoords);

                    moveCoin(index, dropZone);
                    console.log("after move Hand change points:", handChangePoints.current);


                }else{
					//coin is dropped
                    registerDroppedCoin(position.x._value, position.y._value, Date.now());
					droppedCoin.current = true;

                }
            },
        })
    ).current;

    // const toDegrees = (radians) => (radians * 180) / Math.PI;
    const getChangeHand = (gestureState) => {
        const speed = Math.sqrt(gestureState.vx ** 2 + gestureState.vy ** 2); // –ó–∞–≥–∞–ª—å–Ω–∞ —à–≤–∏–¥–∫—ñ—Å—Ç—å
        const directionRadians = Math.atan2(gestureState.dy, gestureState.dx); // –ö—É—Ç —Ä—É—Ö—É
        const directionDegrees = directionRadians * (180 / Math.PI);
        // const directionChange = Math.abs(directionDegrees - lastDirection.current);

        angleHistory.current.push(directionDegrees);
        if (angleHistory.current.length > 13) {
            angleHistory.current.shift();
        }

        const avgAngleChange = Math.abs(
            angleHistory.current[angleHistory.current.length - 1] - 
            angleHistory.current[0]
        );

        if (lastSpeed.current < 0.2 && speed > 0.2 && avgAngleChange > 0.05) {
            // console.log(`angle history ${avgAngleChange}`);
            // console.log(`üîÑ –ú–æ–∂–ª–∏–≤–∞ –∑–º—ñ–Ω–∞ —Ä—É–∫–∏! Speed ${speed}, coordinates(x) ${ position.x._value}`);
            // –†–µ—î—Å—Ç—Ä—É—î–º–æ –º—ñ—Å—Ü–µ –∑–º—ñ–Ω–∏ —Ä—É–∫–∏
            registerHandChange(position.x._value, position.y._value, Date.now());

        }

        lastSpeed.current = speed;

    }

    const getDropZone = (x, y) => {
        // –õ–æ–≥—ñ–∫–∞ –¥–ª—è –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è, –≤ —è–∫—É –∑–æ–Ω—É –ø–æ—Ç—Ä–∞–ø–∏–ª–∞ –º–æ–Ω–µ—Ç–∫–∞
        if (round === 1) {
          if (x > screenWidth * 0.9 - 20) {
            // console.log(`change to right ${ screenWidth * 0.9 - 20}  coordinates are ${x}`);

            return 'right'; // –ü—Ä–∞–≤–∞ –∑–æ–Ω–∞

          }
        } else if (round === 2) {
          if (x < screenWidth * (-0.8) + 40) {
            console.log(`change to left, coin pos ${x}, needed pos ${ screenWidth * 0.1 + 20}`);

            return 'left'; // –õ—ñ–≤–∞ –∑–æ–Ω–∞

          }
        }
        return null;
      };

    return( 
        <>


            <Animated.View
                style={[styles.coinContainer, position.getLayout()]}
                {...panResponder.panHandlers}
            >
            <Image
                source={require("../assets/pennies/frontCoin.png")}
                style={{width: coinSize,
                    height: coinSize,
                    position: "absolute",

                    zIndex: 2,
                    resizeMode: "contain"}}
            />
            </Animated.View>
            <View style={{ position: "absolute", top: 0, left: 0 }}>

            {handChangePoints.current.map((point, index) => (

                <View
                    key={index}
                    style={{
                        position: "absolute",
                        width: 10,
                        height: 10,
                        borderRadius: 5,
                        backgroundColor: "red",
                        left: point.x,
                        top: point.y,
                    }}
                />
            ))}

			<View style={{ position: "absolute", top: 0, left: 0 }}>

			{handChangePointsTest.current.map((point, index) => (

				<View
					key={index}
					style={{
						position: "absolute",
						width: 10,
						height: 10,
						borderRadius: 5,
						backgroundColor: "green",
						left: point.x,
						top: point.y,
					}}
				/>
			))}
			</View>
        </View>
        </>
    );
}

const styles = StyleSheet.create({
    coinContainer: {
        // position: "absolute",
    },
    // coinImage: {
    //     width: coinSize,
    //     height: coinSize,
    //     resizeMode: "contain",
    // },
});